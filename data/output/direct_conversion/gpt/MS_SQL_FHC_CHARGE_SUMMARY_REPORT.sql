DELIMITER $$

CREATE PROCEDURE FHC_CHARGE_SUMMARY_REPORT(IN BEGIN_DATE VARCHAR(255), IN END_DATE VARCHAR(255), OUT P_RECORDSET CURSOR)
BEGIN
  --LOAD POPULATION INTO MEMORY
  TRUNCATE TABLE FHC_CHARGE_SUMMARY_POPULATION_GTT;
  
  INSERT INTO FHC_CHARGE_SUMMARY_POPULATION_GTT
  WITH REPORT_PARAM AS (
    SELECT 
    EPIC_UTIL.EFN_DIN(BEGIN_DATE) AS START_DATE, EPIC_UTIL.EFN_DIN(END_DATE) AS END_DATE
  )
  ,POPULATION AS (
    SELECT PE.PAT_ENC_CSN_ID
    ,PE.PAT_ENC_DATE_REAL
    ,PE.PAT_ID
    ,PT.PAT_MRN_ID
    ,PT.PAT_NAME
    ,PE.HSP_ACCOUNT_ID
    ,PE.CONTACT_DATE
    ,PE.CHARGE_SLIP_NUMBER
    ,ser.PROV_TYPE AS PROV_PRIM_SPEC
    ,ENC_TYPE.name AS ENC_TYPE
    ,ZAS.NAME AS APPT_STATUS_NAME
    ,(CASE WHEN PT.PAT_MRN_ID IS NULL THEN CONCAT('*No Patient Record for #', CAST(PT.PAT_ID AS CHAR), ' *')
        WHEN PT.PAT_NAME IS NULL THEN PT.PAT_MRN_ID 
        ELSE PT.PAT_NAME END) AS PATIENT
    ,(CASE WHEN PE.VISIT_PROV_ID IS NULL THEN '*No Visit Provider*'
        WHEN SER.PROV_ID IS NULL THEN '*No SER Record*'
        ELSE CONCAT(SER.PROV_NAME, ' [', SER.PROV_ID, ']') END) AS VISIT_PROVIDER
    ,DEP.DEPARTMENT_ID
    ,DEP.DEPARTMENT_NAME
    ,center.name AS DEPARTMENT_CENTER
    ,LOC.LOC_ID
    ,LOC.LOC_NAME
    ,PRC.PRC_NAME
    ,(CASE WHEN PE.ENC_CLOSED_YN IS NULL OR PE.ENC_CLOSED_YN = 'N' THEN 'NO' ELSE 'YES' END) AS ENC_CLOSED
    FROM PAT_ENC PE
    INNER JOIN PATIENT PT ON PE.PAT_ID = PT.PAT_ID

    LEFT JOIN CLARITY_SER SER ON PE.VISIT_PROV_ID = SER.PROV_ID
    LEFT JOIN CLARITY_SER_SPEC CSS ON SER.PROV_ID = CSS.PROV_ID AND CSS.LINE = 1
    LEFT JOIN ZC_SPECIALTY ON CSS.SPECIALTY_C = ZC_SPECIALTY.SPECIALTY_C

    LEFT JOIN CLARITY_PRC PRC  ON PE.APPT_PRC_ID = PRC.PRC_ID
    LEFT JOIN ZC_DISP_ENC_TYPE ENC_TYPE ON PE.ENC_TYPE_C = ENC_TYPE.DISP_ENC_TYPE_C
    LEFT JOIN ZC_APPT_STATUS ZAS ON PE.APPT_STATUS_C = ZAS.APPT_STATUS_C

    INNER JOIN CLARITY_DEP DEP ON PE.DEPARTMENT_ID = DEP.DEPARTMENT_ID
    LEFT JOIN ZC_CENTER CENTER ON DEP.CENTER_C = CENTER.CENTER_C

    INNER JOIN CLARITY_LOC LOC ON DEP.REV_LOC_ID = LOC.LOC_ID
    WHERE PE.CHECKIN_TIME IS NOT NULL
    AND PE.APPT_STATUS_C NOT IN (3,4,5)
    AND PE.ENC_TYPE_C NOT IN ('2101','2505')
    AND PE.APPT_PRC_ID NOT IN ('1192')
    AND DEP.DEPARTMENT_ID NOT IN (10803010)
    AND PT.PAT_NAME NOT LIKE 'ZZZ%'
    AND PT.PAT_NAME NOT LIKE 'ZZTEST%'
    AND loc.RPT_GRP_TWELVE_C = '11'
    AND LOC.LOC_ID NOT IN (10793,10794)
    AND PE.CONTACT_DATE BETWEEN (SELECT START_DATE FROM REPORT_PARAM) AND (SELECT END_DATE FROM REPORT_PARAM)
  )
  SELECT * FROM POPULATION;

  --LOAD BILLING INFORMATION IN MEMORY
  TRUNCATE TABLE FHC_CHARGE_SUMMARY_BILLING_GTT;
  
  INSERT INTO FHC_CHARGE_SUMMARY_BILLING_GTT
  WITH BILLING_HTR_CODES AS(
    SELECT 
    PAT_ID
    ,PAT_ENC_DATE_REAL
    ,PAT_ENC_CSN_ID
    ,CODE_POS_ID
    ,CODE
    ,CODE_MODIFIERS
    ,CODE_TYPE
    ,CODE_SERVICE_DATE
    ,CODE_SOURCE
    ,CODE_ID
    ,CODE_UCL_ID
    ,TX_AMOUNT
    FROM (
      SELECT 
      POPULATION.PAT_ID
      ,POPULATION.PAT_ENC_DATE_REAL
      ,POPULATION.PAT_ENC_CSN_ID
      ,HSP_TRANSACTIONS.PLACE_OF_SVC_ID AS CODE_POS_ID
      ,HSP_TRANSACTIONS.HCPCS_CODE AS CODE
      ,HSP_TRANSACTIONS.MODIFIERS AS CODE_MODIFIERS
      ,'CPT' AS CODE_TYPE
      ,SERVICE_DATE AS CODE_SERVICE_DATE
      ,'HTR' AS CODE_SOURCE
      ,HSP_TRANSACTIONS.PROC_ID AS CODE_ID
      ,HSP_TRANSACTIONS.CHG_ROUTER_SRC_ID AS CODE_UCL_ID
      ,HSP_TRANSACTIONS.TX_AMOUNT
      FROM FHC_CHARGE_SUMMARY_POPULATION_GTT POPULATION
      INNER JOIN HSP_TRANSACTIONS ON HSP_TRANSACTIONS.HSP_ACCOUNT_ID = POPULATION.HSP_ACCOUNT_ID
        AND HSP_TRANSACTIONS.PAT_ENC_CSN_ID = POPULATION.PAT_ENC_CSN_ID
    ) AS HTR_PIVOT
  )
  SELECT * FROM BILLING_HTR_CODES;

  -- There are key differences in handling cursors and dynamic SQL between Oracle and MySQL.
  -- As MySQL does not directly support SYS_REFCURSOR type and OPEN FOR statement that exists in Oracle,
  -- developers should adapt the logic to fit MySQL paradigms, such as using TEMPORARY tables and JOINs.

END$$

DELIMITER ;
